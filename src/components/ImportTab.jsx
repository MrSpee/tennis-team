import { useState, useEffect } from 'react';
import { useAuth } from '../context/AuthContext';
import { supabase } from '../lib/supabaseClient';
import './ImportTab.css';

const ImportTab = () => {
  const { player } = useAuth();
  
  // State Management
  const [inputText, setInputText] = useState('');
  const [isProcessing, setIsProcessing] = useState(false);
  const [parsedData, setParsedData] = useState(null);
  const [selectedMatches, setSelectedMatches] = useState([]);
  const [selectedPlayers, setSelectedPlayers] = useState([]);
  const [playerMatchResults, setPlayerMatchResults] = useState([]); // Fuzzy matching results
  const [clubSuggestions, setClubSuggestions] = useState(null); // F√ºr Club-Matching Modal
  const [pendingTeamInfo, setPendingTeamInfo] = useState(null); // Wartet auf Club-Best√§tigung
  const [error, setError] = useState(null);
  const [successMessage, setSuccessMessage] = useState(null);
  const [importStats, setImportStats] = useState(null);
  
  // Team ausw√§hlen (sp√§ter aus Context/Props)
  const [selectedTeamId, setSelectedTeamId] = useState(null);
  const [teams, setTeams] = useState([]);
  const [allTeams, setAllTeams] = useState([]); // Alle Teams f√ºr manuelle Auswahl
  const [manualTeamId, setManualTeamId] = useState(null); // Manuell ausgew√§hltes Team f√ºr Spieler-Import

  // Lade Teams beim Mount
  useEffect(() => {
    loadUserTeams();
  }, [player]);

  const loadUserTeams = async () => {
    if (!player?.id) return;

    try {
      // Lade User-Teams
      const { data, error } = await supabase
        .from('player_teams')
        .select(`
          team_id,
          is_primary,
          team_info (
            id,
            team_name,
            club_name,
            category
          )
        `)
        .eq('player_id', player.id)
        .order('is_primary', { ascending: false });

      if (error) throw error;
      
      const formattedTeams = data.map(pt => ({
        id: pt.team_info.id,
        name: `${pt.team_info.club_name} ${pt.team_info.team_name || ''} (${pt.team_info.category})`,
        isPrimary: pt.is_primary
      }));

      setTeams(formattedTeams);
      
      // Setze Primary Team als Default
      const primaryTeam = formattedTeams.find(t => t.isPrimary);
      if (primaryTeam) {
        setSelectedTeamId(primaryTeam.id);
      }

      // Lade ALLE Teams (f√ºr manuelle Auswahl beim Spieler-Import)
      const { data: allTeamsData, error: allTeamsError } = await supabase
        .from('team_info')
        .select('id, team_name, club_name, category')
        .order('club_name', { ascending: true });

      if (allTeamsError) throw allTeamsError;

      const formattedAllTeams = allTeamsData.map(t => ({
        id: t.id,
        name: `${t.club_name} ${t.team_name || ''} (${t.category})`,
        club_name: t.club_name,
        team_name: t.team_name,
        category: t.category
      }));

      setAllTeams(formattedAllTeams);

    } catch (err) {
      console.error('Error loading teams:', err);
    }
  };

  /**
   * OpenAI API aufrufen zum Parsen
   */
  const handleParseMatches = async () => {
    if (!inputText.trim()) {
      setError('Bitte gib Text ein oder f√ºge eine URL ein.');
      return;
    }

    setIsProcessing(true);
    setError(null);
    setParsedData(null);
    setSuccessMessage(null);

    try {
      console.log('üîÑ Calling parse API...');
      
      // API-Aufruf an Vercel Function (kein teamId n√∂tig - KI erkennt es!)
      const response = await fetch('/api/import/parse-matches', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          text: inputText,
          userEmail: player?.email
        })
      });

      const result = await response.json();

      if (!response.ok) {
        throw new Error(result.error || 'Fehler beim Parsen');
      }

      console.log('‚úÖ Parsing successful:', result);

      // Setze geparste Daten
      setParsedData(result.data);
      
      // Auto-Select: Alle Matches
      if (result.data.matches?.length > 0) {
        setSelectedMatches(result.data.matches.map((_, idx) => idx));
      }
      
      // Spieler: Fuzzy-Matching durchf√ºhren
      if (result.data.players?.length > 0) {
        console.log('üîç Performing player fuzzy-matching...');
        const matchResults = await performPlayerMatching(result.data.players);
        setPlayerMatchResults(matchResults);
        
        // Nur NEUE Spieler standardm√§√üig ausw√§hlen
        const newPlayerIndices = matchResults
          .map((r, idx) => r.status === 'new' ? idx : null)
          .filter(idx => idx !== null);
        setSelectedPlayers(newPlayerIndices);
      }
      
      // Erfolgs-Nachricht (zeigt alles was erkannt wurde)
      let successMsg = 'üéâ KI-Analyse erfolgreich!\n\n';
      if (result.data.team_info) {
        successMsg += `üéæ Team: ${result.data.team_info.club_name}`;
        if (result.data.team_info.team_name) successMsg += ` - ${result.data.team_info.team_name}`;
        successMsg += '\n';
      }
      if (result.data.matches?.length > 0) {
        successMsg += `üìÖ ${result.data.matches.length} Match(es) erkannt\n`;
      }
      if (result.data.players?.length > 0) {
        successMsg += `üë• ${result.data.players.length} Spieler erkannt\n`;
      }
      setSuccessMessage(successMsg);

    } catch (err) {
      console.error('‚ùå Parse error:', err);
      setError(err.message || 'Fehler beim Parsen der Daten');
    } finally {
      setIsProcessing(false);
    }
  };

  /**
   * Matches in Supabase importieren
   */
  const handleImportMatches = async () => {
    if (!parsedData || selectedMatches.length === 0) {
      setError('Keine Matches zum Importieren ausgew√§hlt.');
      return;
    }

    setIsProcessing(true);
    setError(null);

    try {
      const matchesToImport = selectedMatches.map(idx => parsedData.matches[idx]);
      
      console.log('üíæ Importing matches to Supabase:', matchesToImport);
      
      // SCHRITT 1: Finde oder erstelle das Team (inkl. Season)
      let teamId = await findOrCreateTeam(parsedData.team_info, parsedData.season);
      console.log('üéØ Using team_id:', teamId);

      // SCHRITT 2: Pr√ºfe auf Duplikate
      const duplicateCheck = await checkForDuplicates(matchesToImport, teamId);
      
      if (duplicateCheck.duplicates.length > 0) {
        const confirmImport = window.confirm(
          `‚ö†Ô∏è ${duplicateCheck.duplicates.length} Match(es) existieren bereits:\n\n` +
          duplicateCheck.duplicates.map(d => `${d.match_date} - ${d.opponent}`).join('\n') +
          '\n\nTrotzdem importieren? (Duplikate werden √ºbersprungen)'
        );
        
        if (!confirmImport) {
          setIsProcessing(false);
          return;
        }
      }

      // Filtere Duplikate raus
      const uniqueMatches = matchesToImport.filter((match, idx) => {
        return !duplicateCheck.duplicates.some(d => 
          d.match_date === match.match_date && 
          d.opponent === match.opponent
        );
      });

      if (uniqueMatches.length === 0) {
        setError('Alle ausgew√§hlten Matches existieren bereits.');
        setIsProcessing(false);
        return;
      }

      // SCHRITT 3: Formatiere f√ºr Supabase (NUR existierende Spalten!)
      const formattedMatches = uniqueMatches.map(match => ({
        team_id: teamId,
        match_date: match.match_date + ' ' + (match.start_time || '00:00:00'),
        opponent: match.opponent,
        location: match.is_home_match ? 'heim' : 'ausw√§rts',
        venue: match.venue || null,
        season: parsedData.season?.toLowerCase().includes('winter') ? 'winter' : 'summer',
        players_needed: 4,
        created_by: player?.id || null
      }));

      // Insert in Supabase
      const { data, error: insertError } = await supabase
        .from('matches')
        .insert(formattedMatches)
        .select();

      if (insertError) throw insertError;

      console.log('‚úÖ Import successful:', data);

      // Stats
      setImportStats({
        total: matchesToImport.length,
        imported: uniqueMatches.length,
        duplicates: duplicateCheck.duplicates.length,
        cost: parsedData.metadata.cost_estimate
      });

      setSuccessMessage(
        `üéâ Import erfolgreich!\n\n` +
        `‚úÖ ${uniqueMatches.length} neue Match(es) importiert\n` +
        `‚è≠Ô∏è ${duplicateCheck.duplicates.length} Duplikat(e) √ºbersprungen\n` +
        `üí∞ Kosten: ${parsedData.metadata.cost_estimate}`
      );

      // Reset
      setInputText('');
      setParsedData(null);
      setSelectedMatches([]);

    } catch (err) {
      console.error('‚ùå Import error:', err);
      setError(err.message || 'Fehler beim Importieren der Matches');
    } finally {
      setIsProcessing(false);
    }
  };

  /**
   * Finde oder erstelle Team in Supabase
   */
  const findOrCreateTeam = async (teamInfo, season) => {
    if (!teamInfo) {
      throw new Error('Team-Informationen fehlen. KI konnte kein Team erkennen.');
    }

    try {
      console.log('üîç Searching for team:', teamInfo.club_name, teamInfo.team_name);
      
      // SCHRITT 1: Suche existierendes Team in team_info
      const { data: existingTeam, error: searchError } = await supabase
        .from('team_info')
        .select('id')
        .eq('club_name', teamInfo.club_name)
        .eq('team_name', teamInfo.team_name || null)
        .eq('category', teamInfo.category || 'Herren')
        .maybeSingle();

      if (searchError && searchError.code !== 'PGRST116') {
        throw searchError;
      }

      let teamId;

      if (existingTeam) {
        console.log('‚úÖ Team found in team_info:', existingTeam.id);
        teamId = existingTeam.id;
      } else {
        // SCHRITT 2: Team existiert nicht ‚Üí Finde/Erstelle Verein zuerst!
        console.log('‚ö†Ô∏è Team not found, finding/creating club first...');
        
        // 2a. SMART CLUB MATCHING mit Fuzzy-Search
        let clubId = await findOrSuggestClub(teamInfo.club_name, season);
        
        if (!clubId) {
          throw new Error('Club-Matching abgebrochen oder fehlgeschlagen.');
        }

        // 2c. Jetzt Team erstellen mit club_id
        console.log('üìù Creating team with club_id:', clubId);
        
        const { data: newTeam, error: insertError } = await supabase
          .from('team_info')
          .insert({
            club_id: clubId,
            club_name: teamInfo.club_name,
            team_name: teamInfo.team_name || null,
            category: teamInfo.category || 'Herren',
            region: 'Mittelrhein',
            tvm_link: teamInfo.website || null
          })
          .select('id')
          .single();

        if (insertError) throw insertError;

        console.log('‚úÖ Team created in team_info:', newTeam.id);
        teamId = newTeam.id;
      }

      // SCHRITT 3: Pr√ºfe/Erstelle team_seasons Eintrag
      const currentSeason = season || 'Winter 2025/26';
      
      const { data: existingSeason, error: seasonSearchError } = await supabase
        .from('team_seasons')
        .select('id')
        .eq('team_id', teamId)
        .eq('season', currentSeason)
        .maybeSingle();

      if (seasonSearchError && seasonSearchError.code !== 'PGRST116') {
        console.warn('‚ö†Ô∏è Error checking season:', seasonSearchError);
      }

      if (!existingSeason) {
        console.log('üìÖ Creating team_seasons entry...');
        
        // Extrahiere Liga aus teamInfo.league (z.B. "Herren 50 2. Bezirksliga Gr. 054")
        const leagueMatch = teamInfo.league?.match(/(\d+\.\s*\w+)/);
        const league = leagueMatch ? leagueMatch[1] : null;
        
        // Extrahiere Gruppe (z.B. "Gr. 054")
        const groupMatch = teamInfo.league?.match(/Gr\.\s*(\d+)/);
        const groupName = groupMatch ? `Gr. ${groupMatch[1]}` : null;

        const { error: seasonInsertError } = await supabase
          .from('team_seasons')
          .insert({
            team_id: teamId,
            season: currentSeason,
            league: league || '2. Bezirksliga',
            group_name: groupName,
            team_size: 4, // Default f√ºr 4er-Teams
            is_active: true
          });

        if (seasonInsertError) {
          console.warn('‚ö†Ô∏è Could not create season:', seasonInsertError);
        } else {
          console.log('‚úÖ team_seasons created');
        }
      }

      return teamId;

    } catch (err) {
      console.error('‚ùå Error finding/creating team:', err);
      throw new Error('Fehler beim Finden/Erstellen des Teams: ' + err.message);
    }
  };

  /**
   * Pr√ºfe auf Duplikate in der Datenbank
   */
  const checkForDuplicates = async (matches, teamId) => {
    try {
      const dates = matches.map(m => m.match_date);
      
      const { data, error } = await supabase
        .from('matches')
        .select('match_date, opponent')
        .eq('team_id', selectedTeamId)
        .in('match_date', dates);

      if (error) throw error;

      return {
        duplicates: data || [],
        unique: matches.filter(m => 
          !data.some(d => d.match_date === m.match_date && d.opponent === m.opponent)
        )
      };
    } catch (err) {
      console.error('Error checking duplicates:', err);
      return { duplicates: [], unique: matches };
    }
  };

  /**
   * Toggle Match-Auswahl
   */
  const toggleMatchSelection = (index) => {
    setSelectedMatches(prev => 
      prev.includes(index) 
        ? prev.filter(i => i !== index)
        : [...prev, index]
    );
  };

  /**
   * Spieler-Import mit Fuzzy-Matching
   */
  const handleImportPlayers = async () => {
    if (!parsedData?.players || selectedPlayers.length === 0) {
      setError('Keine Spieler zum Importieren ausgew√§hlt.');
      return;
    }

    setIsProcessing(true);
    setError(null);

    try {
      // SCHRITT 1: Team ermitteln (automatisch oder manuell)
      let teamId = null;

      if (parsedData?.team_info) {
        // Automatisch aus geparsten Daten
        teamId = await findOrCreateTeam(parsedData.team_info, parsedData.season);
        console.log('üéØ Team ID (automatisch ermittelt):', teamId);
      } else if (manualTeamId) {
        // Manuell ausgew√§hlt
        teamId = manualTeamId;
        console.log('üéØ Team ID (manuell ausgew√§hlt):', teamId);
      } else {
        // Kein Team ‚Üí Import OHNE Team-Zuordnung (erlaubt!)
        console.log('‚ÑπÔ∏è Spieler werden ohne Team-Zuordnung importiert');
      }

      // SCHRITT 2: F√ºr jeden ausgew√§hlten Spieler
      const playersToImport = selectedPlayers.map(idx => ({
        ...parsedData.players[idx],
        matchResult: playerMatchResults[idx]
      }));

      let created = 0;
      let updated = 0;
      let skipped = 0;

      for (const playerData of playersToImport) {
        const matchResult = playerData.matchResult;

        // FALL 1: Existierender Spieler (exakte √úbereinstimmung)
        if (matchResult?.status === 'exact' && matchResult.playerId) {
          console.log('‚úÖ Updating existing player:', playerData.name);
          
          // Update LK wenn sich ge√§ndert hat
          const { error: updateError } = await supabase
            .from('players')
            .update({
              current_lk: playerData.lk || null,
              last_lk_update: new Date().toISOString()
            })
            .eq('id', matchResult.playerId);

          if (updateError) {
            console.error('‚ùå Error updating player:', updateError);
            skipped++;
          } else {
            updated++;
            
            // Verkn√ºpfe mit Team (falls noch nicht)
            await linkPlayerToTeam(matchResult.playerId, teamId, playerData.is_captain);
          }
          continue;
        }

        // FALL 2: Neuer Spieler ‚Üí imported_players (OHNE user_id!)
        console.log('üÜï Creating imported player:', playerData.name);
        
        const { data: newImportedPlayer, error: insertError } = await supabase
          .from('imported_players')
          .insert({
            name: playerData.name,
            import_lk: playerData.lk || null, // Import-LK (Saison-Start)
            tvm_id_number: playerData.id_number || null,
            team_id: teamId || null, // NULL erlaubt (kein Team)
            position: playerData.position || null,
            is_captain: playerData.is_captain || false,
            status: 'pending',
            imported_by: player?.user_id || null
          })
          .select('id')
          .single();

        if (insertError) {
          console.error('‚ùå Error creating imported player:', insertError);
          skipped++;
        } else {
          created++;
          console.log('‚úÖ Imported player created (will be linked during onboarding)');
        }
      }

      setImportStats({
        total: playersToImport.length,
        created,
        updated,
        skipped
      });

      setSuccessMessage(
        `üéâ Spieler-Import erfolgreich!\n\n` +
        `üÜï ${created} neue Spieler erstellt\n` +
        `üîÑ ${updated} Spieler aktualisiert\n` +
        `‚è≠Ô∏è ${skipped} √ºbersprungen`
      );

      // Reset
      setInputText('');
      setParsedData(null);
      setSelectedPlayers([]);
      setPlayerMatchResults([]);

    } catch (err) {
      console.error('‚ùå Spieler-Import error:', err);
      setError(err.message || 'Fehler beim Importieren der Spieler');
    } finally {
      setIsProcessing(false);
    }
  };

  /**
   * SMART CLUB MATCHING: Finde Verein mit Fuzzy-Matching
   * Ber√ºcksichtigt Schreibfehler, Abk√ºrzungen, etc.
   */
  const findOrSuggestClub = async (clubName) => {
    try {
      console.log('üîç Smart Club Matching for:', clubName);
      
      // 1. Exakte √úbereinstimmung
      const { data: exactMatch, error: exactError } = await supabase
        .from('club_info')
        .select('id, name, city')
        .eq('name', clubName)
        .maybeSingle();

      if (exactError && exactError.code !== 'PGRST116') {
        throw exactError;
      }

      if (exactMatch) {
        console.log('‚úÖ Exact club match:', exactMatch.name);
        return exactMatch.id;
      }

      // 2. Fuzzy-Matching mit allen Vereinen
      const { data: allClubs, error: clubsError } = await supabase
        .from('club_info')
        .select('id, name, city, region');

      if (clubsError) throw clubsError;

      // Berechne Similarity f√ºr alle Clubs
      const matches = allClubs
        .map(club => ({
          ...club,
          similarity: calculateClubSimilarity(clubName, club.name),
          nameMatch: calculateSimilarity(clubName, club.name)
        }))
        .sort((a, b) => b.similarity - a.similarity);

      const bestMatch = matches[0];
      const confidence = Math.round(bestMatch.similarity * 100);

      console.log('üéØ Best match:', bestMatch.name, 'Confidence:', confidence + '%');

      // 3. Hohe Confidence (>95%) ‚Üí Automatisch verwenden
      if (confidence >= 95) {
        console.log('‚úÖ High confidence match, using automatically');
        return bestMatch.id;
      }

      // 4. Mittlere Confidence (70-94%) ‚Üí Nutzer fragen
      if (confidence >= 70) {
        console.log('‚ö†Ô∏è Medium confidence, asking user...');
        
        return new Promise((resolve) => {
          setClubSuggestions({
            searchTerm: clubName,
            suggestions: matches.slice(0, 3),
            onConfirm: (clubId) => {
              setClubSuggestions(null);
              resolve(clubId);
            },
            onCancel: () => {
              setClubSuggestions(null);
              resolve(null);
            }
          });
        });
      }

      // 5. Niedrige Confidence (<70%) ‚Üí Verein fehlt
      throw new Error(
        `‚ùå Verein "${clubName}" nicht gefunden!\n\n` +
        `√Ñhnlichste Vereine in der DB:\n` +
        matches.slice(0, 3).map((m, i) => `${i + 1}. ${m.name} (${Math.round(m.similarity * 100)}%)`).join('\n') +
        `\n\nBitte lege den Verein im "üè¢ Vereine" Tab an.`
      );

    } catch (err) {
      console.error('‚ùå Error in findOrSuggestClub:', err);
      throw err;
    }
  };

  /**
   * Erweiterte Club-Similarity (ber√ºcksichtigt Abk√ºrzungen, etc.)
   */
  const calculateClubSimilarity = (search, clubName) => {
    const s1 = search.toLowerCase().trim();
    const s2 = clubName.toLowerCase().trim();
    
    // Exakte √úbereinstimmung
    if (s1 === s2) return 1.0;
    
    // Substring-Match (z.B. "VKC K√∂ln" in "VKC K√∂ln e.V.")
    if (s2.includes(s1) || s1.includes(s2)) return 0.95;
    
    // Entferne h√§ufige Suffixe
    const cleanS1 = s1.replace(/\s*(e\.?v\.?|tennis|tc|sv|tg|thc|gg)\s*/gi, ' ').trim();
    const cleanS2 = s2.replace(/\s*(e\.?v\.?|tennis|tc|sv|tg|thc|gg)\s*/gi, ' ').trim();
    
    if (cleanS1 === cleanS2) return 0.9;
    
    // Levenshtein Distance
    return calculateSimilarity(s1, s2);
  };

  /**
   * Verkn√ºpfe Spieler mit Team
   */
  const linkPlayerToTeam = async (playerId, teamId, isCaptain) => {
    try {
      // Pr√ºfe ob Verkn√ºpfung schon existiert
      const { data: existing } = await supabase
        .from('player_teams')
        .select('id')
        .eq('player_id', playerId)
        .eq('team_id', teamId)
        .maybeSingle();

      if (existing) {
        console.log('‚ÑπÔ∏è Player already linked to team');
        return;
      }

      // Erstelle Verkn√ºpfung
      await supabase
        .from('player_teams')
        .insert({
          player_id: playerId,
          team_id: teamId,
          role: isCaptain ? 'captain' : 'player',
          is_primary: false // Nur wenn explizit gew√ºnscht
        });

      console.log('‚úÖ Player linked to team');
    } catch (err) {
      console.error('‚ö†Ô∏è Error linking player to team:', err);
    }
  };

  /**
   * Fuzzy-Matching f√ºr Spieler (pr√ºft players UND imported_players)
   */
  const performPlayerMatching = async (players) => {
    if (!players || players.length === 0) return [];

    try {
      // Lade BEIDE: registrierte Spieler UND importierte Spieler
      const [
        { data: registeredPlayers, error: playersError },
        { data: importedPlayers, error: importedError }
      ] = await Promise.all([
        supabase.from('players').select('id, name, current_lk'),
        supabase.from('imported_players').select('id, name, import_lk').eq('status', 'pending')
      ]);

      if (playersError) throw playersError;
      if (importedError) console.warn('‚ö†Ô∏è Could not load imported_players:', importedError);

      // Kombiniere beide Listen (normalisiere LK-Feld-Namen)
      const existingPlayers = [
        ...(registeredPlayers || []).map(p => ({ ...p, lk: p.current_lk, source: 'players' })),
        ...(importedPlayers || []).map(p => ({ ...p, lk: p.import_lk, source: 'imported' }))
      ];

      // F√ºr jeden importierten Spieler: Fuzzy-Match
      const matchResults = players.map(importPlayer => {
        // Exakte √úbereinstimmung (Name)
        const exactMatch = existingPlayers.find(
          p => p.name.toLowerCase() === importPlayer.name.toLowerCase()
        );

        if (exactMatch) {
          return {
            status: 'exact',
            playerId: exactMatch.id,
            existingName: exactMatch.name,
            existingLk: exactMatch.current_lk,
            confidence: 100
          };
        }

        // Fuzzy Match (√§hnliche Namen)
        const fuzzyMatches = existingPlayers
          .map(p => ({
            player: p,
            similarity: calculateSimilarity(importPlayer.name, p.name)
          }))
          .filter(m => m.similarity > 0.7)
          .sort((a, b) => b.similarity - a.similarity);

        if (fuzzyMatches.length > 0) {
          return {
            status: 'fuzzy',
            playerId: fuzzyMatches[0].player.id,
            existingName: fuzzyMatches[0].player.name,
            existingLk: fuzzyMatches[0].player.current_lk,
            confidence: Math.round(fuzzyMatches[0].similarity * 100),
            alternatives: fuzzyMatches.slice(1, 3)
          };
        }

        // Kein Match
        return {
          status: 'new',
          playerId: null,
          confidence: 0
        };
      });

      return matchResults;
    } catch (err) {
      console.error('Error performing fuzzy matching:', err);
      return [];
    }
  };

  /**
   * Einfache String-Similarity (Levenshtein Distance)
   */
  const calculateSimilarity = (str1, str2) => {
    const s1 = str1.toLowerCase();
    const s2 = str2.toLowerCase();
    
    if (s1 === s2) return 1;
    
    const len1 = s1.length;
    const len2 = s2.length;
    const maxLen = Math.max(len1, len2);
    
    if (maxLen === 0) return 1;
    
    const distance = levenshteinDistance(s1, s2);
    return 1 - (distance / maxLen);
  };

  const levenshteinDistance = (str1, str2) => {
    const matrix = [];
    
    for (let i = 0; i <= str2.length; i++) {
      matrix[i] = [i];
    }
    
    for (let j = 0; j <= str1.length; j++) {
      matrix[0][j] = j;
    }
    
    for (let i = 1; i <= str2.length; i++) {
      for (let j = 1; j <= str1.length; j++) {
        if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
          matrix[i][j] = matrix[i - 1][j - 1];
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1,
            matrix[i][j - 1] + 1,
            matrix[i - 1][j] + 1
          );
        }
      }
    }
    
    return matrix[str2.length][str1.length];
  };

  /**
   * Beispiel-Text einf√ºgen (f√ºr Testing)
   */
  const insertExampleText = () => {
    setInputText(`VKC K√∂ln
Stadt K√∂ln
Alfred Sch√ºtte Allee 51
51105 K√∂ln
http://www.vkc-koeln.de

Mannschaftsf√ºhrer
Kliemt Mathias (-)

Herren 50 2. Bezirksliga Gr. 054
Herren 50 1 (4er)

Meldeliste:
Position	Mannschaft	Name	LK	ID-Nr.	Info	MF	Nation
1	1	Gregor Kaul	6.8	17160158			GER
2	1	Hubertus von Henninges	8.2	17403842			GER
3	1	Gary Meuser	10.4	17104633			GER
4	1	Mathias Kliemt	13.7	17282054		MF	GER
5	2	Michael Kostka	14.6	16902597			GER

Spielplan:
Datum	Spielort	Heim Verein	Gastverein	Matchpunkte	S√§tze	Spiele	
11.10.2025, 18:00	Cologne Sportspark	VKC K√∂ln 1	TG Leverkusen 2	0:0	0:0	0:0	offen
29.11.2025, 18:00	K√∂lnerTHC Stadion RW	K√∂lnerTHC Stadion RW 2	VKC K√∂ln 1	0:0	0:0	0:0	offen
17.01.2026, 18:00	Cologne Sportspark	VKC K√∂ln 1	TPSK 1925 K√∂ln 1	0:0	0:0	0:0	offen`);
  };

  return (
    <div className="import-tab">
      <div className="import-header">
        <h2>ü§ñ Universeller KI-Import</h2>
        <p>Kopiere TVM-Daten hier rein - die KI erkennt automatisch Matches, Spieler & Teams!</p>
      </div>

      {/* Team-Info wird automatisch erkannt */}
      {parsedData?.team_info && (
        <div className="import-section">
          <div className="team-info-banner">
            <h3>üéæ Erkanntes Team:</h3>
            <div className="team-details">
              <strong>{parsedData.team_info.club_name}</strong>
              {parsedData.team_info.team_name && ` - ${parsedData.team_info.team_name}`}
              {parsedData.team_info.category && ` (${parsedData.team_info.category})`}
              <br />
              {parsedData.team_info.league && <span className="meta-badge">{parsedData.team_info.league}</span>}
            </div>
          </div>
        </div>
      )}

      {/* Text-Eingabe */}
      <div className="import-section">
        <div className="input-header">
          <label htmlFor="match-text">üìã TVM-Meldeliste:</label>
          <button 
            onClick={insertExampleText}
            className="btn-example"
            type="button"
          >
            üìù Beispiel einf√ºgen
          </button>
        </div>
        
        <textarea
          id="match-text"
          value={inputText}
          onChange={(e) => setInputText(e.target.value)}
          placeholder="Kopiere hier die komplette TVM-Seite (inkl. Team-Info und Spielplan)...

Die KI erkennt automatisch:
‚úÖ Verein & Mannschaft
‚úÖ Alle Spieltage
‚úÖ Spieler (falls Meldeliste dabei)"
          rows={12}
          className="match-input"
        />

        <div className="input-actions">
          <button
            onClick={handleParseMatches}
            disabled={!inputText.trim() || isProcessing}
            className="btn-parse"
          >
            {isProcessing ? '‚è≥ Verarbeite...' : 'ü§ñ KI analysieren'}
          </button>
          
          <button
            onClick={() => {
              setInputText('');
              setParsedData(null);
              setError(null);
              setSuccessMessage(null);
            }}
            className="btn-clear"
            type="button"
          >
            üóëÔ∏è Zur√ºcksetzen
          </button>
        </div>
      </div>

      {/* Error Message */}
      {error && (
        <div className="message error-message">
          <span className="message-icon">‚ùå</span>
          <div>
            <strong>Fehler:</strong>
            <p>{error}</p>
          </div>
        </div>
      )}

      {/* Success Message */}
      {successMessage && !parsedData && (
        <div className="message success-message">
          <span className="message-icon">‚úÖ</span>
          <div>
            <strong>Erfolgreich!</strong>
            <p style={{ whiteSpace: 'pre-line' }}>{successMessage}</p>
          </div>
        </div>
      )}

      {/* Parsed Matches Vorschau */}
      {parsedData && parsedData.matches && parsedData.matches.length > 0 && (
        <div className="import-section">
          <div className="preview-header">
            <h3>üéØ Erkannte Matches ({parsedData.matches.length})</h3>
            <div className="preview-meta">
              {parsedData.season && <span className="meta-badge">üìÖ {parsedData.season}</span>}
              {parsedData.category && <span className="meta-badge">üéæ {parsedData.category}</span>}
              <span className="meta-badge">üí∞ {parsedData.metadata.cost_estimate}</span>
            </div>
          </div>

          <div className="matches-preview">
            {parsedData.matches.map((match, idx) => (
              <div 
                key={idx}
                className={`match-card ${selectedMatches.includes(idx) ? 'selected' : ''}`}
                onClick={() => toggleMatchSelection(idx)}
              >
                <div className="match-checkbox">
                  <input 
                    type="checkbox"
                    checked={selectedMatches.includes(idx)}
                    onChange={() => toggleMatchSelection(idx)}
                    onClick={(e) => e.stopPropagation()}
                  />
                </div>
                
                <div className="match-details">
                  <div className="match-header">
                    <span className="match-date">
                      üìÖ {new Date(match.match_date).toLocaleDateString('de-DE', { 
                        weekday: 'short', 
                        day: '2-digit', 
                        month: '2-digit', 
                        year: 'numeric' 
                      })}
                    </span>
                    {match.start_time && (
                      <span className="match-time">üïê {match.start_time} Uhr</span>
                    )}
                    {match.matchday && (
                      <span className="match-day">üéØ Spieltag {match.matchday}</span>
                    )}
                  </div>
                  
                  <div className="match-opponent">
                    <span className={`home-away-badge ${match.is_home_match ? 'home' : 'away'}`}>
                      {match.is_home_match ? 'üè† Heim' : '‚úàÔ∏è Ausw√§rts'}
                    </span>
                    <strong className="opponent-name">{match.opponent}</strong>
                  </div>
                  
                  {match.venue && (
                    <div className="match-venue">
                      üìç {match.venue}
                      {match.address && `, ${match.address}`}
                    </div>
                  )}
                  
                  {match.league && (
                    <div className="match-league">
                      üèÜ {match.league}
                    </div>
                  )}
                  
                  {match.notes && (
                    <div className="match-notes">
                      üí¨ {match.notes}
                    </div>
                  )}
                </div>
              </div>
            ))}
          </div>

          <div className="import-actions">
            <button
              onClick={handleImportMatches}
              disabled={selectedMatches.length === 0 || isProcessing}
              className="btn-import"
            >
              {isProcessing 
                ? '‚è≥ Importiere...' 
                : `üíæ ${selectedMatches.length} Match(es) importieren`
              }
            </button>
            
            <button
              onClick={() => {
                setParsedData(null);
                setSelectedMatches([]);
              }}
              className="btn-cancel"
              type="button"
            >
              ‚ùå Abbrechen
            </button>
          </div>
        </div>
      )}

      {/* Parsed Players Vorschau */}
      {parsedData && parsedData.players && parsedData.players.length > 0 && (
        <div className="import-section">
          <div className="preview-header">
            <h3>üë• Erkannte Spieler ({parsedData.players.length})</h3>
            <div className="preview-meta">
              {parsedData.season && <span className="meta-badge">üìÖ {parsedData.season}</span>}
              <span className="meta-badge">üí∞ {parsedData.metadata.cost_estimate}</span>
            </div>
          </div>

          {/* Manuelle Team-Auswahl (falls keine Team-Info erkannt) */}
          {!parsedData.team_info && (
            <div style={{ 
              padding: '1rem', 
              background: '#fef3c7', 
              border: '1px solid #f59e0b', 
              borderRadius: '8px',
              marginBottom: '1rem'
            }}>
              <div style={{ fontSize: '0.9rem', fontWeight: '600', marginBottom: '0.5rem', color: '#92400e' }}>
                ‚ö†Ô∏è Keine Team-Informationen erkannt
              </div>
              <div style={{ fontSize: '0.85rem', color: '#78350f', marginBottom: '0.75rem' }}>
                W√§hle optional ein Team aus, dem die Spieler zugeordnet werden sollen. 
                Du kannst Spieler auch ohne Team importieren.
              </div>
              <select
                value={manualTeamId || ''}
                onChange={(e) => setManualTeamId(e.target.value || null)}
                style={{
                  width: '100%',
                  padding: '0.5rem',
                  border: '1px solid #f59e0b',
                  borderRadius: '6px',
                  fontSize: '0.875rem',
                  background: 'white'
                }}
              >
                <option value="">üö´ Kein Team (Spieler ohne Zuordnung)</option>
                {allTeams.map(team => (
                  <option key={team.id} value={team.id}>
                    {team.name}
                  </option>
                ))}
              </select>
            </div>
          )}

          <div className="players-preview">
            {parsedData.players.map((player, idx) => {
              const matchResult = playerMatchResults[idx] || { status: 'new' };
              
              return (
                <div 
                  key={idx}
                  className={`player-card ${selectedPlayers.includes(idx) ? 'selected' : ''} ${matchResult.status}`}
                  onClick={() => {
                    setSelectedPlayers(prev => 
                      prev.includes(idx) ? prev.filter(i => i !== idx) : [...prev, idx]
                    );
                  }}
                >
                  <div className="match-checkbox">
                    <input 
                      type="checkbox"
                      checked={selectedPlayers.includes(idx)}
                      onChange={(e) => {
                        e.stopPropagation();
                        setSelectedPlayers(prev => 
                          prev.includes(idx) ? prev.filter(i => i !== idx) : [...prev, idx]
                        );
                      }}
                    />
                  </div>
                  
                  <div className="player-details">
                    <div className="player-header">
                      <strong className="player-name">{player.name}</strong>
                      <span className={`player-status-badge ${matchResult.status}`}>
                        {matchResult.status === 'exact' && `‚úÖ Existiert (${matchResult.confidence}%)`}
                        {matchResult.status === 'fuzzy' && `‚ö†Ô∏è √Ñhnlich (${matchResult.confidence}%)`}
                        {matchResult.status === 'new' && 'üÜï Neu'}
                      </span>
                    </div>
                    
                    <div className="player-info">
                      <span className="player-lk">üèÜ LK {player.lk}</span>
                      <span className="player-position">üìç Pos. {player.position}</span>
                      {player.is_captain && <span className="captain-badge">üëë MF</span>}
                      <span className="player-id">üÜî {player.id_number}</span>
                    </div>
                    
                    {/* Existing Player Info */}
                    {matchResult.status !== 'new' && matchResult.existingName && (
                      <div className="existing-player-info">
                        <div style={{ fontSize: '0.85rem', color: '#6b7280', marginTop: '0.5rem' }}>
                          üíæ <strong>Existierender Spieler:</strong> {matchResult.existingName}
                          {matchResult.existingLk && ` (LK ${matchResult.existingLk})`}
                        </div>
                        {player.lk !== matchResult.existingLk && (
                          <div style={{ fontSize: '0.8rem', color: '#f59e0b', marginTop: '0.25rem' }}>
                            ‚ö° LK-Update: {matchResult.existingLk} ‚Üí {player.lk}
                          </div>
                        )}
                      </div>
                    )}
                  </div>
                </div>
              );
            })}
          </div>

          <div className="import-actions">
            <button
              onClick={handleImportPlayers}
              disabled={selectedPlayers.length === 0 || isProcessing}
              className="btn-import"
            >
              {isProcessing 
                ? '‚è≥ Importiere...' 
                : `üë• ${selectedPlayers.length} Spieler importieren`
              }
            </button>
            
            <button
              onClick={() => {
                setParsedData(null);
                setSelectedPlayers([]);
                setPlayerMatchResults([]);
              }}
              className="btn-cancel"
              type="button"
            >
              ‚ùå Abbrechen
            </button>
          </div>
        </div>
      )}

      {/* Import Stats */}
      {importStats && (
        <div className="import-stats">
          <h4>üìä Import-Statistik</h4>
          <div className="stats-grid">
            <div className="stat-item">
              <span className="stat-label">Gesamt:</span>
              <span className="stat-value">{importStats.total}</span>
            </div>
            {importStats.imported !== undefined && (
              <div className="stat-item success">
                <span className="stat-label">Importiert:</span>
                <span className="stat-value">‚úÖ {importStats.imported}</span>
              </div>
            )}
            {importStats.created !== undefined && (
              <div className="stat-item success">
                <span className="stat-label">Erstellt:</span>
                <span className="stat-value">üÜï {importStats.created}</span>
              </div>
            )}
            {importStats.updated !== undefined && (
              <div className="stat-item info">
                <span className="stat-label">Aktualisiert:</span>
                <span className="stat-value">üîÑ {importStats.updated}</span>
              </div>
            )}
            {importStats.duplicates !== undefined && (
              <div className="stat-item warning">
                <span className="stat-label">Duplikate:</span>
                <span className="stat-value">‚è≠Ô∏è {importStats.duplicates}</span>
              </div>
            )}
            {importStats.skipped !== undefined && (
              <div className="stat-item warning">
                <span className="stat-label">√úbersprungen:</span>
                <span className="stat-value">‚è≠Ô∏è {importStats.skipped}</span>
              </div>
            )}
            <div className="stat-item info">
              <span className="stat-label">Kosten:</span>
              <span className="stat-value">üí∞ {importStats.cost}</span>
            </div>
          </div>
        </div>
      )}

      {/* Info Box */}
      <div className="import-info">
        <h4>‚ÑπÔ∏è Wie funktioniert der Smart-Import?</h4>
        <ul>
          <li>üìã Kopiere die <strong>komplette TVM-Seite</strong> (Team-Info, Spielplan, Meldeliste)</li>
          <li>ü§ñ Die KI erkennt <strong>automatisch</strong> was im Text ist:
            <ul style={{ marginTop: '0.5rem', paddingLeft: '1.5rem' }}>
              <li>üéæ Team & Verein</li>
              <li>üìÖ Matches & Spieltage</li>
              <li>üë• Spieler & LK</li>
            </ul>
          </li>
          <li>‚úÖ Du w√§hlst aus was importiert werden soll</li>
          <li>üîç Duplikate & Schreibfehler werden erkannt</li>
          <li>üí∞ Kosten: ~$0.01 pro Import</li>
        </ul>
      </div>

      {/* Club-Suggestion Modal */}
      {clubSuggestions && (
        <div className="modal-overlay" onClick={clubSuggestions.onCancel}>
          <div className="modal-content" onClick={(e) => e.stopPropagation()}>
            <div className="modal-header">
              <h3>üè¢ Verein zuordnen</h3>
              <button onClick={clubSuggestions.onCancel} className="modal-close">‚úï</button>
            </div>
            
            <div className="modal-body">
              <p style={{ marginBottom: '1rem', color: '#6b7280' }}>
                Der Verein <strong>"{clubSuggestions.searchTerm}"</strong> wurde nicht exakt gefunden.
                <br />
                Meinst du einen dieser Vereine?
              </p>
              
              <div className="club-suggestions">
                {clubSuggestions.suggestions.map((club, idx) => (
                  <div 
                    key={club.id}
                    className="club-suggestion-card"
                    onClick={() => clubSuggestions.onConfirm(club.id)}
                  >
                    <div className="suggestion-header">
                      <strong>{club.name}</strong>
                      <span className={`confidence-badge ${club.similarity >= 0.9 ? 'high' : club.similarity >= 0.8 ? 'medium' : 'low'}`}>
                        {Math.round(club.similarity * 100)}% Match
                      </span>
                    </div>
                    <div className="suggestion-details">
                      {club.city && <span>üìç {club.city}</span>}
                      {club.region && <span>üó∫Ô∏è {club.region}</span>}
                    </div>
                  </div>
                ))}
              </div>
              
              <div style={{ marginTop: '1.5rem', textAlign: 'center' }}>
                <button 
                  onClick={clubSuggestions.onCancel}
                  className="btn-cancel"
                  style={{ width: 'auto', padding: '0.75rem 2rem' }}
                >
                  ‚ùå Keiner passt / Abbrechen
                </button>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default ImportTab;

